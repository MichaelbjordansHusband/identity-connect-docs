## Keys

Several key pairs participate in message passing, transaction signing, account connecting, etc. Here we will enumerate them, and their acronyms.

$pk_X$ **denotes a **Public Key** used for purpose $X$ **(ex: dApp, wallet, account, etc), whereas $sk_X$ **is the matching ********************Secret Key********************.

- **Account Keys** $(pk_A, sk_A)$: these are held in the wallet, and are used to sign transactions that are submitted on chain, or messages to prove a wallet possesses a given secret key. These are *not expected to be ephemeral*.
- **************dApp Keys************** $(pk_D, sk_D)$: generated by the dApp *per pairing*, and stored locally within the application. These are ephemeral keys. These ****************must not**************** be reused between pairings, and IC will enforce their uniqueness.
- **********************Wallet Keys********************** $(pk_W, sk_W)$: generated by the wallet when it establishes a connection to IC (anonymous or otherwise), *unique per wallet connection*, never re-used. This allows IC to verify commands from a given wallet to disconnect pairings, add accounts, etc.
- **************IC Keys************** $(pk_{IC}, sk_{IC})$: generated by IC when a wallet establishes a connection, *unique per wallet connection,* never re-used. This allows IC to verify commands from a given wallet to disconnect pairings, add accounts, etc.

To disambiguate Ed25519 from X25519 keys, we will prefix any X25519 keys with an `x` like so: `xPke/xSke`. Ed25519 keys are used for signing, whereas X25519 keys are used for encryption.

### Key Flows

Despite having so many key pairs, they are only used in three ways.

1. **Wallet ←→ Identity Connect (IC)**
    1. Identity connect creates a keypair $(pk_{IC}, sk_{IC})$ when a `Wallet` entry is created.
    2. The wallet generates a keypair $(pk_W, sk_W)$ and submits the public key $pk_W$ to IC when confirming the connection.
2. ****************************Account ←→ dApp****************************
    1. The dApp creates a keypair $(pk_D, sk_D)$: for each pairing. Messages between an account $(pk_A, sk_A)$ and a dApp use these keys for encryption (via X25519) and authorization.
    2. **Account private keys** $sk_A$ ****(and their counterpart X25519 keys) **are only used to decrypt and sign: they are never used to encrypt.**
3. **Wallet ←→ dApp** (anonymous pairing only)
    1. The dApp creates a keypair $(pk_D, sk_D)$ for each pairing
    2. The wallet generates a keypair $(pk_W, sk_W)$ and submits the public key $pk_W$ to IC when confirming the connection
    3. This message contains a signed `AccountConnectInfoSerialized`, which proves the wallet controls the $sk_A$ associated with this pairing
